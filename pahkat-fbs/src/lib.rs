// automatically generated by the FlatBuffers compiler, do not modify

#![allow(unused_imports, dead_code)]

use std::cmp::Ordering;
use std::mem;

use flatbuffers::EndianScalar;

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum WindowsExecutableFlags {
    TargetSystem = 1,
    TargetUser = 2,
    RequiresReboot = 64,
    RequiresUninstallReboot = 128,
}

pub const ENUM_MIN_WINDOWS_EXECUTABLE_FLAGS: u8 = 1;
pub const ENUM_MAX_WINDOWS_EXECUTABLE_FLAGS: u8 = 128;

impl<'a> flatbuffers::Follow<'a> for WindowsExecutableFlags {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::read_scalar_at::<Self>(buf, loc)
    }
}

impl flatbuffers::EndianScalar for WindowsExecutableFlags {
    #[inline]
    fn to_little_endian(self) -> Self {
        let n = u8::to_le(self as u8);
        let p = &n as *const u8 as *const WindowsExecutableFlags;
        unsafe { *p }
    }
    #[inline]
    fn from_little_endian(self) -> Self {
        let n = u8::from_le(self as u8);
        let p = &n as *const u8 as *const WindowsExecutableFlags;
        unsafe { *p }
    }
}

impl flatbuffers::Push for WindowsExecutableFlags {
    type Output = WindowsExecutableFlags;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<WindowsExecutableFlags>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_WINDOWS_EXECUTABLE_FLAGS: [WindowsExecutableFlags; 4] = [
    WindowsExecutableFlags::TargetSystem,
    WindowsExecutableFlags::TargetUser,
    WindowsExecutableFlags::RequiresReboot,
    WindowsExecutableFlags::RequiresUninstallReboot,
];

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum WindowsExecutableKind {
    NONE = 0,
    Msi = 1,
    Inno = 2,
    Nsis = 3,
}

pub const ENUM_MIN_WINDOWS_EXECUTABLE_KIND: u8 = 0;
pub const ENUM_MAX_WINDOWS_EXECUTABLE_KIND: u8 = 3;

impl<'a> flatbuffers::Follow<'a> for WindowsExecutableKind {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::read_scalar_at::<Self>(buf, loc)
    }
}

impl flatbuffers::EndianScalar for WindowsExecutableKind {
    #[inline]
    fn to_little_endian(self) -> Self {
        let n = u8::to_le(self as u8);
        let p = &n as *const u8 as *const WindowsExecutableKind;
        unsafe { *p }
    }
    #[inline]
    fn from_little_endian(self) -> Self {
        let n = u8::from_le(self as u8);
        let p = &n as *const u8 as *const WindowsExecutableKind;
        unsafe { *p }
    }
}

impl flatbuffers::Push for WindowsExecutableKind {
    type Output = WindowsExecutableKind;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<WindowsExecutableKind>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_WINDOWS_EXECUTABLE_KIND: [WindowsExecutableKind; 4] = [
    WindowsExecutableKind::NONE,
    WindowsExecutableKind::Msi,
    WindowsExecutableKind::Inno,
    WindowsExecutableKind::Nsis,
];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_WINDOWS_EXECUTABLE_KIND: [&'static str; 4] = ["NONE", "Msi", "Inno", "Nsis"];

pub fn enum_name_windows_executable_kind(e: WindowsExecutableKind) -> &'static str {
    let index = e as u8;
    ENUM_NAMES_WINDOWS_EXECUTABLE_KIND[index as usize]
}

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum MacOSPackageFlags {
    TargetSystem = 1,
    TargetUser = 2,
    RequiresReboot = 64,
    RequiresUninstallReboot = 128,
}

pub const ENUM_MIN_MAC_OSPACKAGE_FLAGS: u8 = 1;
pub const ENUM_MAX_MAC_OSPACKAGE_FLAGS: u8 = 128;

impl<'a> flatbuffers::Follow<'a> for MacOSPackageFlags {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::read_scalar_at::<Self>(buf, loc)
    }
}

impl flatbuffers::EndianScalar for MacOSPackageFlags {
    #[inline]
    fn to_little_endian(self) -> Self {
        let n = u8::to_le(self as u8);
        let p = &n as *const u8 as *const MacOSPackageFlags;
        unsafe { *p }
    }
    #[inline]
    fn from_little_endian(self) -> Self {
        let n = u8::from_le(self as u8);
        let p = &n as *const u8 as *const MacOSPackageFlags;
        unsafe { *p }
    }
}

impl flatbuffers::Push for MacOSPackageFlags {
    type Output = MacOSPackageFlags;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<MacOSPackageFlags>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MAC_OSPACKAGE_FLAGS: [MacOSPackageFlags; 4] = [
    MacOSPackageFlags::TargetSystem,
    MacOSPackageFlags::TargetUser,
    MacOSPackageFlags::RequiresReboot,
    MacOSPackageFlags::RequiresUninstallReboot,
];

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum PayloadTag {
    NONE = 0,
    WindowsExecutable = 1,
    MacOSPackage = 2,
    TarballPackage = 3,
}

pub const ENUM_MIN_PAYLOAD: u8 = 0;
pub const ENUM_MAX_PAYLOAD: u8 = 3;

impl<'a> flatbuffers::Follow<'a> for PayloadTag {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::read_scalar_at::<Self>(buf, loc)
    }
}

impl flatbuffers::EndianScalar for PayloadTag {
    #[inline]
    fn to_little_endian(self) -> Self {
        let n = u8::to_le(self as u8);
        let p = &n as *const u8 as *const PayloadTag;
        unsafe { *p }
    }
    #[inline]
    fn from_little_endian(self) -> Self {
        let n = u8::from_le(self as u8);
        let p = &n as *const u8 as *const PayloadTag;
        unsafe { *p }
    }
}

impl flatbuffers::Push for PayloadTag {
    type Output = PayloadTag;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<PayloadTag>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PAYLOAD: [PayloadTag; 4] = [
    PayloadTag::NONE,
    PayloadTag::WindowsExecutable,
    PayloadTag::MacOSPackage,
    PayloadTag::TarballPackage,
];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_PAYLOAD: [&'static str; 4] = [
    "NONE",
    "WindowsExecutable",
    "MacOSPackage",
    "TarballPackage",
];

pub fn enum_name_payload(e: PayloadTag) -> &'static str {
    let index = e as u8;
    ENUM_NAMES_PAYLOAD[index as usize]
}

pub struct PayloadUnionTableOffset {}
#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum Package {
    NONE = 0,
    Descriptor = 1,
    Synthetic = 2,
    Redirect = 3,
}

pub const ENUM_MIN_PACKAGE: u8 = 0;
pub const ENUM_MAX_PACKAGE: u8 = 3;

impl<'a> flatbuffers::Follow<'a> for Package {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::read_scalar_at::<Self>(buf, loc)
    }
}

impl flatbuffers::EndianScalar for Package {
    #[inline]
    fn to_little_endian(self) -> Self {
        let n = u8::to_le(self as u8);
        let p = &n as *const u8 as *const Package;
        unsafe { *p }
    }
    #[inline]
    fn from_little_endian(self) -> Self {
        let n = u8::from_le(self as u8);
        let p = &n as *const u8 as *const Package;
        unsafe { *p }
    }
}

impl flatbuffers::Push for Package {
    type Output = Package;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<Package>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PACKAGE: [Package; 4] = [
    Package::NONE,
    Package::Descriptor,
    Package::Synthetic,
    Package::Redirect,
];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_PACKAGE: [&'static str; 4] = ["NONE", "Descriptor", "Synthetic", "Redirect"];

pub fn enum_name_package(e: Package) -> &'static str {
    let index = e as u8;
    ENUM_NAMES_PACKAGE[index as usize]
}

pub struct PackageUnionTableOffset {}
pub enum WindowsExecutableOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct WindowsExecutable<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for WindowsExecutable<'a> {
    type Inner = WindowsExecutable<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> WindowsExecutable<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        WindowsExecutable { _tab: table }
    }

    pub const VT_URL: flatbuffers::VOffsetT = 4;
    pub const VT_PRODUCT_CODE: flatbuffers::VOffsetT = 6;
    pub const VT_SIZE_: flatbuffers::VOffsetT = 8;
    pub const VT_INSTALLED_SIZE: flatbuffers::VOffsetT = 10;
    pub const VT_FLAGS: flatbuffers::VOffsetT = 12;
    pub const VT_KIND: flatbuffers::VOffsetT = 14;
    pub const VT_ARGS: flatbuffers::VOffsetT = 16;
    pub const VT_UNINSTALL_ARGS: flatbuffers::VOffsetT = 18;

    #[inline]
    pub fn url(&self) -> &'a str {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(WindowsExecutable::VT_URL, None)
            .unwrap()
    }
    #[inline]
    pub fn product_code(&self) -> &'a str {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(WindowsExecutable::VT_PRODUCT_CODE, None)
            .unwrap()
    }
    #[inline]
    pub fn size_(&self) -> u64 {
        self._tab
            .get::<u64>(WindowsExecutable::VT_SIZE_, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn installed_size(&self) -> u64 {
        self._tab
            .get::<u64>(WindowsExecutable::VT_INSTALLED_SIZE, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn flags(&self) -> WindowsExecutableFlags {
        self._tab
            .get::<WindowsExecutableFlags>(
                WindowsExecutable::VT_FLAGS,
                Some(WindowsExecutableFlags::TargetSystem),
            )
            .unwrap()
    }
    #[inline]
    pub fn kind(&self) -> WindowsExecutableKind {
        self._tab
            .get::<WindowsExecutableKind>(
                WindowsExecutable::VT_KIND,
                Some(WindowsExecutableKind::NONE),
            )
            .unwrap()
    }
    #[inline]
    pub fn args(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(WindowsExecutable::VT_ARGS, None)
    }
    #[inline]
    pub fn uninstall_args(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(WindowsExecutable::VT_UNINSTALL_ARGS, None)
    }
}
pub enum MacOSPackageOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct MacOSPackage<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MacOSPackage<'a> {
    type Inner = MacOSPackage<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> MacOSPackage<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        MacOSPackage { _tab: table }
    }
    pub const VT_URL: flatbuffers::VOffsetT = 4;
    pub const VT_PKG_ID: flatbuffers::VOffsetT = 6;
    pub const VT_SIZE_: flatbuffers::VOffsetT = 8;
    pub const VT_INSTALLED_SIZE: flatbuffers::VOffsetT = 10;
    pub const VT_FLAGS: flatbuffers::VOffsetT = 12;

    #[inline]
    pub fn url(&self) -> &'a str {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(MacOSPackage::VT_URL, None)
            .unwrap()
    }
    #[inline]
    pub fn pkg_id(&self) -> &'a str {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(MacOSPackage::VT_PKG_ID, None)
            .unwrap()
    }
    #[inline]
    pub fn size_(&self) -> u64 {
        self._tab
            .get::<u64>(MacOSPackage::VT_SIZE_, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn installed_size(&self) -> u64 {
        self._tab
            .get::<u64>(MacOSPackage::VT_INSTALLED_SIZE, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn flags(&self) -> MacOSPackageFlags {
        self._tab
            .get::<MacOSPackageFlags>(
                MacOSPackage::VT_FLAGS,
                Some(MacOSPackageFlags::TargetSystem),
            )
            .unwrap()
    }
}
pub enum TarballPackageOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct TarballPackage<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TarballPackage<'a> {
    type Inner = TarballPackage<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> TarballPackage<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TarballPackage { _tab: table }
    }
    pub const VT_URL: flatbuffers::VOffsetT = 4;
    pub const VT_SIZE_: flatbuffers::VOffsetT = 6;
    pub const VT_INSTALLED_SIZE: flatbuffers::VOffsetT = 8;

    #[inline]
    pub fn url(&self) -> &'a str {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(TarballPackage::VT_URL, None)
            .unwrap()
    }
    #[inline]
    pub fn size_(&self) -> u64 {
        self._tab
            .get::<u64>(TarballPackage::VT_SIZE_, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn installed_size(&self) -> u64 {
        self._tab
            .get::<u64>(TarballPackage::VT_INSTALLED_SIZE, Some(0))
            .unwrap()
    }
}
pub enum TargetOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Target<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Target<'a> {
    type Inner = Target<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

pub enum Payload<'a> {
    WindowsExecutable(WindowsExecutable<'a>),
    MacOSPackage(MacOSPackage<'a>),
    TarballPackage(TarballPackage<'a>),
}

impl<'a> Target<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Target { _tab: table }
    }

    pub const VT_PLATFORM: flatbuffers::VOffsetT = 4;
    pub const VT_PAYLOAD_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_PAYLOAD: flatbuffers::VOffsetT = 8;
    pub const VT_DEPENDENCIES_KEYS: flatbuffers::VOffsetT = 10;
    pub const VT_DEPENDENCIES_VALUES: flatbuffers::VOffsetT = 12;
    pub const VT_ARCH: flatbuffers::VOffsetT = 14;

    #[inline]
    pub fn platform(&self) -> &'a str {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(Target::VT_PLATFORM, None)
            .unwrap()
    }
    #[inline]
    pub fn payload_type(&self) -> PayloadTag {
        self._tab
            .get::<PayloadTag>(Target::VT_PAYLOAD_TYPE, Some(PayloadTag::NONE))
            .unwrap()
    }
    // #[inline]
    // pub fn payload(&self) -> flatbuffers::Table<'a> {
    //     self._tab
    //         .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Target::VT_PAYLOAD, None)
    //         .unwrap()
    // }
    #[inline]
    pub fn payload(&self) -> Option<Payload<'a>> {
        let table = self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Target::VT_PAYLOAD, None)?;
        match self.payload_type() {
            PayloadTag::WindowsExecutable => Some(Payload::WindowsExecutable(WindowsExecutable::init_from_table(table))),
            PayloadTag::MacOSPackage => Some(Payload::MacOSPackage(MacOSPackage::init_from_table(table))),
            PayloadTag::TarballPackage => Some(Payload::TarballPackage(TarballPackage::init_from_table(table))),
            _ => None,
        }
    }
    #[inline]
    pub fn dependencies_keys(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<flatbuffers::ForwardsUOffset<&'a str>>,
        >>(Target::VT_DEPENDENCIES_KEYS, None)
    }
    #[inline]
    pub fn dependencies_values(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<flatbuffers::ForwardsUOffset<&'a str>>,
        >>(Target::VT_DEPENDENCIES_VALUES, None)
    }
    #[inline]
    pub fn dependencies(&self) -> Option<Map<'a, &'a str, &'a str>> {
        let keys = self.dependencies_keys()?;
        let values = self.dependencies_values()?;
        Some(Map::new(keys, values))
    }

    #[inline]
    pub fn arch(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(Target::VT_ARCH, None)
    }
    // #[inline]
    // #[allow(non_snake_case)]
    // pub fn payload_as_windows_executable(&self) -> Option<WindowsExecutable<'a>> {
    //     if self.payload_type() == PayloadTag::WindowsExecutable {
    //         self.payload()
    //             .map(|u| WindowsExecutable::init_from_table(u))
    //     } else {
    //         None
    //     }
    // }

    // #[inline]
    // #[allow(non_snake_case)]
    // pub fn payload_as_mac_ospackage(&self) -> Option<MacOSPackage<'a>> {
    //     if self.payload_type() == PayloadTag::MacOSPackage {
    //         self.payload().map(|u| MacOSPackage::init_from_table(u))
    //     } else {
    //         None
    //     }
    // }

    // #[inline]
    // #[allow(non_snake_case)]
    // pub fn payload_as_tarball_package(&self) -> Option<TarballPackage<'a>> {
    //     if self.payload_type() == PayloadTag::TarballPackage {
    //         self.payload().map(|u| TarballPackage::init_from_table(u))
    //     } else {
    //         None
    //     }
    // }
}
pub enum ReleaseOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Release<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Release<'a> {
    type Inner = Release<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Release<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Release { _tab: table }
    }

    pub const VT_VERSION_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_VERSION: flatbuffers::VOffsetT = 6;
    pub const VT_TARGET: flatbuffers::VOffsetT = 8;
    pub const VT_CHANNEL: flatbuffers::VOffsetT = 10;
    pub const VT_AUTHORS: flatbuffers::VOffsetT = 12;
    pub const VT_LICENSE: flatbuffers::VOffsetT = 14;
    pub const VT_LICENSE_URL: flatbuffers::VOffsetT = 16;

    #[inline]
    pub fn version_type(&self) -> u8 {
        self._tab
            .get::<u8>(Release::VT_VERSION_TYPE, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn version(&self) -> &'a str {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(Release::VT_VERSION, None)
            .unwrap()
    }
    #[inline]
    pub fn target(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Target<'a>>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<flatbuffers::ForwardsUOffset<Target<'a>>>,
        >>(Release::VT_TARGET, None)
    }
    #[inline]
    pub fn channel(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(Release::VT_CHANNEL, None)
    }
    #[inline]
    pub fn authors(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<flatbuffers::ForwardsUOffset<&'a str>>,
        >>(Release::VT_AUTHORS, None)
    }
    #[inline]
    pub fn license(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(Release::VT_LICENSE, None)
    }
    #[inline]
    pub fn license_url(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(Release::VT_LICENSE_URL, None)
    }
}
pub enum DescriptorOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Descriptor<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Descriptor<'a> {
    type Inner = Descriptor<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Descriptor<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Descriptor { _tab: table }
    }
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_RELEASE: flatbuffers::VOffsetT = 6;
    pub const VT_NAME_KEYS: flatbuffers::VOffsetT = 8;
    pub const VT_NAME_VALUES: flatbuffers::VOffsetT = 10;
    pub const VT_DESCRIPTION_KEYS: flatbuffers::VOffsetT = 12;
    pub const VT_DESCRIPTION_VALUES: flatbuffers::VOffsetT = 14;
    pub const VT_TAGS: flatbuffers::VOffsetT = 16;

    #[inline]
    pub fn id(&self) -> &'a str {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(Descriptor::VT_ID, None)
            .unwrap()
    }
    #[inline]
    pub fn release(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Release<'a>>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<flatbuffers::ForwardsUOffset<Release<'a>>>,
        >>(Descriptor::VT_RELEASE, None)
    }
    #[inline]
    pub fn name_keys(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<flatbuffers::ForwardsUOffset<&'a str>>,
        >>(Descriptor::VT_NAME_KEYS, None)
    }
    #[inline]
    pub fn name_values(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<flatbuffers::ForwardsUOffset<&'a str>>,
        >>(Descriptor::VT_NAME_VALUES, None)
    }
    #[inline]
    pub fn name(&self) -> Option<Map<'a, &'a str, &'a str>> {
        let keys = self.name_keys()?;
        let values = self.name_values()?;
        Some(Map::new(keys, values))
    }
    #[inline]
    pub fn description_keys(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<flatbuffers::ForwardsUOffset<&'a str>>,
        >>(Descriptor::VT_DESCRIPTION_KEYS, None)
    }
    #[inline]
    pub fn description_values(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<flatbuffers::ForwardsUOffset<&'a str>>,
        >>(Descriptor::VT_DESCRIPTION_VALUES, None)
    }
    #[inline]
    pub fn description(&self) -> Option<Map<'a, &'a str, &'a str>> {
        let keys = self.description_keys()?;
        let values = self.description_values()?;
        Some(Map::new(keys, values))
    }
    #[inline]
    pub fn tags(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<flatbuffers::ForwardsUOffset<&'a str>>,
        >>(Descriptor::VT_TAGS, None)
    }
}

pub enum SyntheticOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Synthetic<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Synthetic<'a> {
    type Inner = Synthetic<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Synthetic<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Synthetic { _tab: table }
    }
    pub const VT_TODO: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn todo(&self) -> u8 {
        self._tab.get::<u8>(Synthetic::VT_TODO, Some(0)).unwrap()
    }
}

pub enum RedirectOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Redirect<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Redirect<'a> {
    type Inner = Redirect<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Redirect<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Redirect { _tab: table }
    }
    pub const VT_URL: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn url(&self) -> &'a str {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(Redirect::VT_URL, None)
            .unwrap()
    }
}

pub enum PackagesOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Packages<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Packages<'a> {
    type Inner = Packages<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Packages<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Packages { _tab: table }
    }

    pub const VT_PACKAGES_KEYS: flatbuffers::VOffsetT = 4;
    pub const VT_PACKAGES_VALUES_TYPES: flatbuffers::VOffsetT = 6;
    pub const VT_PACKAGES_VALUES: flatbuffers::VOffsetT = 8;

    #[inline]
    pub fn packages_keys(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<flatbuffers::ForwardsUOffset<&'a str>>,
        >>(Packages::VT_PACKAGES_KEYS, None)
    }
    #[inline]
    pub fn packages_values_types(&self) -> Option<&'a [u8]> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                Packages::VT_PACKAGES_VALUES_TYPES,
                None,
            )
            .map(|v| v.safe_slice())
    }
    #[inline]
    pub fn packages_values(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Descriptor<'a>>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<flatbuffers::ForwardsUOffset<Descriptor<'a>>>,
        >>(Packages::VT_PACKAGES_VALUES, None)
    }

    pub fn packages(&'a self) -> Map<'a, &'a str, Descriptor<'a>> {
        let package_keys = self.packages_keys().unwrap();
        let package_values = self.packages_values().unwrap();
        let map = Map::new(package_keys, package_values);
        map
    }
}

#[inline]
pub fn get_root_as_packages<'a>(buf: &'a [u8]) -> Packages<'a> {
    flatbuffers::get_root::<Packages<'a>>(buf)
}

#[inline]
pub fn get_size_prefixed_root_as_packages<'a>(buf: &'a [u8]) -> Packages<'a> {
    flatbuffers::get_size_prefixed_root::<Packages<'a>>(buf)
}

#[inline]
pub fn finish_packages_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Packages<'a>>,
) {
    fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_packages_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Packages<'a>>,
) {
    fbb.finish_size_prefixed(root, None);
}

pub struct Map<'a, K, V> {
    keys: flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<K>>,
    values: flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<V>>,
}

impl<'a, K, V> From<Map<'a, K, V>>
    for std::collections::BTreeMap<
        <<flatbuffers::ForwardsUOffset<K> as flatbuffers::Follow<'a>>::Inner as ToOwned>::Owned,
        <<flatbuffers::ForwardsUOffset<V> as flatbuffers::Follow<'a>>::Inner as ToOwned>::Owned,
    >
where
    K: PartialEq,
    flatbuffers::ForwardsUOffset<K>: flatbuffers::Follow<'a>,
    flatbuffers::ForwardsUOffset<V>: flatbuffers::Follow<'a>,
    <flatbuffers::ForwardsUOffset<K> as flatbuffers::Follow<'a>>::Inner: PartialEq + ToOwned,
    <<flatbuffers::ForwardsUOffset<K> as flatbuffers::Follow<'a>>::Inner as ToOwned>::Owned: PartialEq + Ord,
    <flatbuffers::ForwardsUOffset<V> as flatbuffers::Follow<'a>>::Inner: ToOwned,
{
    fn from(
        value: Map<'a, K, V>,
    ) -> std::collections::BTreeMap<
        <<flatbuffers::ForwardsUOffset<K> as flatbuffers::Follow<'a>>::Inner as ToOwned>::Owned,
        <<flatbuffers::ForwardsUOffset<V> as flatbuffers::Follow<'a>>::Inner as ToOwned>::Owned,
    > {
        let mut out = std::collections::BTreeMap::new();
        for (k, v) in value.iter() {
            out.insert(k.to_owned(), v.to_owned());
        }
        out
    }
}

impl<'a, K, V> Map<'a, K, V>
where
    K: PartialEq,
    flatbuffers::ForwardsUOffset<K>: flatbuffers::Follow<'a>,
    flatbuffers::ForwardsUOffset<V>: flatbuffers::Follow<'a>,
    <flatbuffers::ForwardsUOffset<K> as flatbuffers::Follow<'a>>::Inner: PartialEq,
{
    #[inline]
    fn new(
        keys: flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<K>>,
        values: flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<V>>,
    ) -> Map<'a, K, V> {
        Map { keys, values }
    }

    #[inline]
    pub fn iter(
        &self,
    ) -> impl Iterator<
        Item = (
            <flatbuffers::ForwardsUOffset<K> as flatbuffers::Follow<'a>>::Inner,
            <flatbuffers::ForwardsUOffset<V> as flatbuffers::Follow<'a>>::Inner,
        ),
    > {
        self.keys.iter().zip(self.values.iter())
    }

    #[inline]
    pub fn get(
        &self,
        key: <flatbuffers::ForwardsUOffset<K> as flatbuffers::Follow<'a>>::Inner,
    ) -> Option<<flatbuffers::ForwardsUOffset<V> as flatbuffers::Follow<'a>>::Inner> {
        self.keys
            .iter()
            .position(|x| x == key)
            .map(|i| self.values.get(i))
    }

    #[inline]
    pub fn keys(
        &self,
    ) -> impl Iterator<Item = <flatbuffers::ForwardsUOffset<K> as flatbuffers::Follow<'a>>::Inner>
    {
        self.keys.iter()
    }

    #[inline]
    pub fn key(
        &self,
        index: usize,
    ) -> Option<<flatbuffers::ForwardsUOffset<K> as flatbuffers::Follow<'a>>::Inner> {
        if index >= self.keys.len() {
            None
        } else {
            Some(self.keys.get(index))
        }
    }

    #[inline]
    pub fn value(
        &self,
        index: usize,
    ) -> Option<<flatbuffers::ForwardsUOffset<V> as flatbuffers::Follow<'a>>::Inner> {
        if index >= self.values.len() {
            None
        } else {
            Some(self.values.get(index))
        }
    }
}
